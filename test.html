<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .container {
      overflow-x: hidden;
      overflow-y: auto;
      width: 100%;
      height: 100%;
    }

    .list {
      display: flex;
      justify-content: flex-start;
      align-items: flex-start;
      flex-wrap: wrap;
      list-style: none;
      width: 80%;
      margin: 0 auto 0;
      padding: 0;
      
    }

    .item {
      width: 20%;
      margin-right: 10px;
      margin-bottom: 10px;
      height: 200px;
      border-radius: 10px;
    }

    #slide {
      position: absolute;
      top: 30px;
      right: 50px;

    }

    #slide li {
      cursor: pointer;
    }

    #slide li:hover {
      color: green;
    }

    .fliper-wrap {
      perspective: 1000px;
      transform-style: preserve-3d;
    }

    .fliper {
      position: relative;
      width: 300px;
      height: 500px;
      border-radius: 10px;
      transition: 1s;
    }

    .fliper:hover {
      transform: rotateY(180deg);
    }

    .front,
    .back {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      background-color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 50px;
      transition: 1s;
      backface-visibility: hidden;
    }

    .front {
      background-color: palevioletred;
    }

    .back {
      z-index: 1;
      background-color: #ccc;
      transform: rotateY(180deg);
    } */

    .flip-container {
      perspective: 1000px;
    }

    /* flip the pane when hovered */
    .flip-container:hover .flipper {
      transform: rotateY(180deg);
    }

    .flip-container {}

    /* flip speed goes here */
    .flipper {
      position: relative;
      width: 320px;
      height: 480px;
      transition: 0.6s;
      transform-style: preserve-3d;

      position: relative;
    }

    /* hide back of pane during swap */
    .front,
    .back {
      backface-visibility: hidden;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 50px;
    }

    /* front pane, placed above back */
    .front {
      z-index: 2;
      background-color: palevioletred;
    }

    /* back, initially hidden pane */
    .back {
      transform: rotateY(180deg);
      background-color: seagreen;
    }
  </style>
</head>

<body>

  <div class="flip-container">
    <div class="flipper">
      <div class="front">正</div>
      <div class="back">反</div>
    </div>
  </div>

  <!-- <div class="fliper-wrap">
    <div class="fliper">
      <div class="front">
        正
      </div>
      <div class="back">
        反
      </div>
    </div>
  </div> -->

  <!-- <ul id="slide"></ul>
 
  <div class="container">
    <ul id="ul" class="list"></ul>
  </div> -->


  <script src="https://cdn.bootcdn.net/ajax/libs/scrollReveal.js/4.0.9/scrollreveal.js"></script>
  <script>

    const body = document.body
    // body.style.height = window.innerHeight + 'px'
    // body.style.overflow = 'hidden'
    const ul = document.getElementById('ul')
    const slide = document.getElementById('slide')
    const container = document.querySelector('.container')
    const fragment = document.createDocumentFragment()
    const fragment2 = document.createDocumentFragment()

    // container.addEventListener('scroll', e => {
    //   console.log('scrollTop: ', container.scrollTop)
    // }, top)

    // slide.addEventListener('click', e => {
    //   const el = e.target
    //   console.log(el)
    //   const node = document.getElementById(el.dataset.anchor)
    //   const offsetTop = node.offsetTop
    //   const scrollTop = node.scrollTop
    //   const br = node.getBoundingClientRect()
    //   console.log(node)
    //   console.log('to: ', offsetTop)
    //   // console.log('scrollTop: ', scrollTop)
    //   console.log('from: ', container.scrollTop)
    //   move(container.scrollTop, offsetTop - container.scrollTop, 2000, (x, y) => {
    //     container.scrollTop = y
    //   }).then(() => {
    //     console.log('then: ', container.scrollTop)
    //   })
    // }, false)


    // const createLi = (id, backgroundColor) => {
    //   const li = document.createElement('li')
    //   li.classList.add('item')
    //   li.style.backgroundColor = backgroundColor
    //   li.id = id
    //   return li
    // } 

    // const random = (min, max) => {
    //   return Math.round(Math.random() * (max - min) + min)
    // }


    let n = 200

    const color = () => {
      const cs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f']
      const max = cs.length - 1
      const hex = 'ffffff'
      const list = hex.split('').map(() => {
        return cs[random(0, max)]
      })
      return '#' + list.join('')
    }

    // const s = [1, 15, 39, 60, 100, 130, 180, 198]

    // while(n--) {
    //   fragment.appendChild(createLi(n, color()))

    //   if (s.indexOf(n) >= 0 ){
    //     const li = document.createElement('li')
    //     li.setAttribute('data-anchor', n)
    //     li.innerHTML = 'Anchor' + n
    //     fragment2.appendChild(li)
    //   }

    // }

    // ul.appendChild(fragment)
    // slide.appendChild(fragment2)
    // setTimeout(() => {
    //   ScrollReveal().sync();
    // }, 100)
    // const sr = init()

    // function init() {
    //   const sr = ScrollReveal({
    //     reset: true,
    //     distance: '100px',
    //     duration: 1000,
    //     opacity: 0,
    //     scale: 0.8,
    //     delay: 100,
    //     cleanup: true,
    //     container: '.container'
    //   })
    //   sr.reveal('.item')
    //   return sr
    // }

    function scroll2(container, scrollTop, duration) {
      return new Promise((resolve, reject) => {
        let from = container.scrollTop
        let to = scrollTop
        let n = from > to ? -1 : 1
        let t = 0
        console.log('from: ', from)
        console.log('to: ', to)
        function move(st) {
          if (t === 0) {
            t = st
            return requestAnimationFrame(move)
          }
          const delta = st - t
          const val = easeInOutQuad(delta, from, to, duration)
          const step = val * n
          from = step
          container.scrollTop = from
          console.log('delta: ', delta)
          console.log('step: ', step)
          console.log('from: ', from)
          if (delta < duration) {
            requestAnimationFrame(move)
          } else {
            // container.scrollTop = to
            resolve()
          }
        }
        requestAnimationFrame(move)
      })
    }

    function easeInOutQuad(currentTime, startValue, changeValue, duration) {
      currentTime /= duration / 2;
      if (currentTime < 1) return changeValue / 2 * currentTime * currentTime + startValue;
      currentTime--;
      return -changeValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    }

    function scrollTo(container, from, to, duration) {
      return new Promise((resolve, reject) => {
        console.log('from: ', from)
        console.log('to: ', to)
        let t = 0
        const move = st => {
          if (t === 0) {
            t = st
          }
          const delta = st - t
          const current = easeInOutQuad(delta, from, to, duration)
          container.scrollTop = current
          console.log('delta: ', delta)
          console.log('current: ', current)
          if (delta < duration) {
            requestAnimationFrame(move)
          } else {
            // container.scrollTop = to
            console.log('end: ', current)
            resolve()
          }
        }
        requestAnimationFrame(move)
      })
    }

    function move(from, to, duration, callback) {
      return new Promise((resolve, reject) => {
        if (typeof callback !== 'function') {
          return reject(new TypeError('callback muse be a function.'))
        }
        if (from === to) {
          return resolve()
        }
        const isIncrease = to > from
        const max = isIncrease ? to : from
        const min = isIncrease ? from : to
        let t = 0
        const move = s => {
          if (t === 0) {
            t = s
          }
          const x = s - t
          const y = easeInOutCubic(x, min, max, duration)
          if (x < duration) {
            callback(x, isIncrease ? y : max - y)
            requestAnimationFrame(move)
          } else {
            // callback(duration, to)
            resolve()
          }
        }
        requestAnimationFrame(move)
      })
    }

    function easeInOutCubic(elapsed, initialValue, amountOfChange, duration) {
      if ((elapsed /= duration / 2) < 1) {
        return amountOfChange / 2 * elapsed * elapsed * elapsed + initialValue;
      }
      return amountOfChange / 2 * ((elapsed -= 2) * elapsed * elapsed + 2) + initialValue;
    }

    // // move(0, 100, 2000)
    // move(100, 0, 2000, (x, y) => {
    //   console.log(`x: ${x}, y: ${y}`)
    // }).then(() => {
    //   move(-100, 0, 2000, (x, y) => {
    //   console.log(`x: ${x}, y: ${y}`)
    // })
    // })

    function easeInOutCubic(x) {
      return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    }

    let i = 0
    while (i <= 1) {
      const y = easeInOutCubic(i)
      console.log(`x: ${i}, y: ${y}`)
      i = parseFloat((i + 0.05).toPrecision(7))
    }




  </script>
</body>

</html>